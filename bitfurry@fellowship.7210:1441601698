#lang scheme

;;Solution 1.29
(define (cube x) (* x x x))
(define (sum term i next j)
  (if (> i j)
      0
      (+ (term i)
         (sum term (next i) next j))))
(define (odd? i)
  (= (remainder i 2) 1))
(define (simpson f a b n)
  (let ((h (/ (- b a) n)))
    (define (xi i) (+ a (* i h)))
    (define (next i) (+ i 1))
    (define (term i)
      (cond ((or (= i 0) (= i n)) (f (xi i)))
            ((odd? i) (* 4 (f (xi i))))
            (else (* 2 (f (xi i))))))
    (if (odd? n)
        (display "n must be even!")
        (* (sum term 0 next n) (/ h 3)))))
(display "Solution 1.29")
(newline)
(simpson cube 0 1 100)
(simpson cube 0 1 1000)

;; Solution 1.30

(define (sum-new term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))


;; Solution 1.31

; recursive
(define (product-r term i next j)
  (if (> i j)
      1
      (* (term i)
         (product-r term (next i) next j))))

; iterative
(define (product-i term i next j)
  (define (iter i result)
    (if (> i j)
        result
        (iter (next i) (* result (term i)))))
  (iter i 1))

(define (fact product-f n)
  (define (term i) i)
  (define (next i) (+ i 1))
  (product-f term 1 next n))

(define (pi product-f n)
  (define (odd? i)
    (= (remainder i 2) 1))
  (define (term i)
    (if (odd? i)
        (/ (+ i 1) (+ i 2))
        (/ (+ i 2) (+ i 1))))
  (define (next i) (+ i 1))
  (* 4 (product-f term 1.0 next n)))

(newline)
(display "Solution 1.31")
(newline)
(fact product-r 10)
(fact product-i 10)
(pi product-r 1000)
(pi product-i 1000)


;; Solution 1.32
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))

(define (inc a) ( + a 1))

(define (sum-acc a b)
  (accumulate + 0 identity a inc b))

(define (product-acc a b)
  (accumulate * 1 identity a inc b))

(define (accumulate-iter combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter a null-value))


;; Solution 1.33
(define (square a) (* a a))

(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (filtered-accumulate pred? combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (if (pred? a)
                           (combiner result (term a))
                           result))))
  (iter a null-value))

(define (sum-squared-primes a b)
  (filtered-accumulate prime? + 0 square a inc b))

(define (relative-prime-product n)
  (define (relatively-prime? i)
    (define (gcd a b)
      (if (= b 0)
          a
          (gcd b (remainder a b))))
    (= (gcd i n) 1))
  (filtered-accumulate relatively-prime? * 1 identity 0 inc n))
